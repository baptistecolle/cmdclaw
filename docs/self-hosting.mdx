---
title: "Self-Hosting"
description: "Deploy your own CmdClaw instance with Docker, PostgreSQL, and Redis."
---

## Prerequisites

- [Bun](https://bun.sh) (recommended) or Node.js
- [Docker](https://docs.docker.com/get-docker/) and Docker Compose
- API keys for the AI providers you want to use (Anthropic, OpenAI, or Google)

## Setup

<Steps>
  <Step title="Clone the repository">
    ```bash
    git clone https://github.com/baptistecolle/cmdclaw.git
    cd cmdclaw/app
    ```
  </Step>
  <Step title="Install dependencies">
    ```bash
    bun install
    ```
  </Step>
  <Step title="Start local services">
    This starts PostgreSQL, Redis, and MinIO (S3-compatible storage):

    ```bash
    docker compose up -d
    ```
  </Step>
  <Step title="Configure environment variables">
    ```bash
    cp .env.example .env
    ```

    Edit `.env` and fill in your API keys and configuration. At minimum you need:

    - `DATABASE_URL` -- PostgreSQL connection string
    - `REDIS_URL` -- Redis connection string
    - `ANTHROPIC_API_KEY` -- For Claude
    - `BETTER_AUTH_SECRET` -- Authentication secret
  </Step>
  <Step title="Set up the database">
    Push the schema to your database:

    ```bash
    bun db:push
    ```

    Optionally seed with initial data:

    ```bash
    bun db:seed
    ```
  </Step>
  <Step title="Start the app">
    ```bash
    bun dev
    ```

    The app will be available at `http://localhost:3000`.
  </Step>
</Steps>

## Docker Compose (all-in-one)

For a fully containerized setup (app + worker + WS server + DB + Redis + MinIO),
save the file below as `docker-compose.selfhost.yml` in `cmdclaw/app`, then run:

```bash
docker compose -f docker-compose.selfhost.yml up -d --build
```

Then open `http://localhost:3000`.

### docker-compose.selfhost.yml

```yaml
name: cmdclaw-selfhost

services:
  app:
    build: .
    container_name: cmdclaw-app
    env_file: .env
    environment:
      NODE_ENV: production
      PORT: "3000"
      HOSTNAME: "0.0.0.0"
    ports:
      - "3000:3000"
    depends_on:
      database:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy
    restart: unless-stopped

  worker:
    build: .
    container_name: cmdclaw-worker
    env_file: .env
    command: ["bun", "worker"]
    depends_on:
      database:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped

  ws:
    build: .
    container_name: cmdclaw-ws
    env_file: .env
    command: ["bun", "scripts/start-ws.ts"]
    environment:
      WS_PORT: "4097"
    ports:
      - "4097:4097"
    depends_on:
      database:
        condition: service_healthy
    restart: unless-stopped

  database:
    image: postgres
    container_name: cmdclaw-postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: cmdclaw
    ports:
      - "5432:5432"
    volumes:
      - cmdclaw_postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:8-alpine
    container_name: cmdclaw-redis
    ports:
      - "6379:6379"
    volumes:
      - cmdclaw_redis_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  minio:
    image: minio/minio
    container_name: cmdclaw-minio
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: ${S3_ACCESS_KEY_ID}
      MINIO_ROOT_PASSWORD: ${S3_SECRET_ACCESS_KEY}
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - cmdclaw_minio_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "mc", "ready", "local"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  cmdclaw_postgres_data:
  cmdclaw_redis_data:
  cmdclaw_minio_data:
```

## BYOC daemon (local compute)

The BYOC daemon is meant to run on the user's local machine, not inside the
server Docker stack. This lets the server execute tools and sandbox commands on
their device.

1. Install the daemon using the provided scripts in `src/daemon/scripts/`.
2. Authenticate the device:

```bash
cmdclaw-daemon auth
```

3. Start the daemon:

```bash
cmdclaw-daemon start
```

If you don't want BYOC:

- Set `E2B_API_KEY` and `E2B_TEMPLATE` to use E2B cloud sandboxes.
- Or set `DAYTONA_API_KEY` (plus optional `DAYTONA_SERVER_URL` / `DAYTONA_TARGET`) to use Daytona sandboxes.

## Background worker

CmdClaw uses BullMQ for background jobs (e.g., processing integrations). Start the worker in a separate terminal:

```bash
bun worker
```

## WebSocket server (BYOC)

The WebSocket server handles daemon connections and runs separately from Next.js:

```bash
bun ws:dev
```

## Useful commands

| Command | Description |
|---------|-------------|
| `bun dev` | Start the dev server |
| `bun build` | Production build |
| `bun worker` | Start the background job worker |
| `bun ws:dev` | Start the BYOC WebSocket server |
| `bun db:push` | Push schema changes to the database |
| `bun db:studio` | Open Drizzle Studio (database browser) |
| `bun db:seed` | Seed the database |
| `bun lint:fix` | Fix linting issues |
| `bun typecheck` | Run the TypeScript type checker |
| `bun test` | Run unit tests |
| `bun test:e2e` | Run end-to-end tests |

## Tech stack

| Layer | Technology |
|-------|------------|
| Web | Next.js 16, React 19, Tailwind CSS 4 |
| API | ORPC, Better Auth |
| Database | PostgreSQL, Drizzle ORM |
| AI | Anthropic Claude, OpenAI, Google Gemini |
| Queue | BullMQ, Redis |
| Storage | S3 / MinIO |
| Sandbox | E2B, Daytona |
